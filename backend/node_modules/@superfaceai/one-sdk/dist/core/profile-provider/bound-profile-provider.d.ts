import type { MapDocumentNode, NormalizedProfileProviderSettings, ProfileDocumentNode, ProviderJson, SecurityValues } from '@superfaceai/ast';
import type { IConfig, ICrypto, ILogger, MapInterpreterError, ProfileParameterError } from '../../interfaces';
import type { NonPrimitive, Result, SDKExecutionError, UnexpectedError } from '../../lib';
import type { Events, Interceptable } from '../events';
import type { AuthCache, IFetch, SecurityConfiguration } from '../interpreter';
import type { IServiceSelector } from '../services';
export interface IBoundProfileProvider {
    perform<TInput extends NonPrimitive | undefined = undefined, TResult = any>(usecase: string, input?: TInput, parameters?: Record<string, string>, securityValues?: SecurityValues[]): Promise<Result<TResult, ProfileParameterError | MapInterpreterError | UnexpectedError | SDKExecutionError>>;
}
export declare class BoundProfileProvider implements IBoundProfileProvider {
    private readonly profileAst;
    private readonly mapAst;
    private readonly provider;
    private readonly config;
    readonly configuration: {
        services: IServiceSelector;
        profileProviderSettings?: NormalizedProfileProviderSettings;
        security: SecurityConfiguration[];
        parameters?: Record<string, string>;
    };
    private readonly crypto;
    private readonly fetchInstance;
    private readonly logger?;
    private profileValidator;
    private readonly logSensitive;
    constructor(profileAst: ProfileDocumentNode, mapAst: MapDocumentNode, provider: ProviderJson, config: IConfig, configuration: {
        services: IServiceSelector;
        profileProviderSettings?: NormalizedProfileProviderSettings;
        security: SecurityConfiguration[];
        parameters?: Record<string, string>;
    }, crypto: ICrypto, fetchInstance: IFetch & Interceptable & AuthCache, logger?: ILogger | undefined, events?: Events);
    /**
     * Performs the usecase while validating input and output against the profile definition.
     *
     * Note that the `TInput` and `TResult` types cannot be checked for compatibility with the profile definition, so the caller
     * is responsible for ensuring that the cast is safe.
     */
    perform<TInput extends NonPrimitive | undefined = undefined, TResult = any>(usecase: string, input?: TInput, parameters?: Record<string, string>, securityValues?: SecurityValues[]): Promise<Result<TResult, ProfileParameterError | MapInterpreterError | UnexpectedError | SDKExecutionError>>;
    private composeInput;
    private mergeParameters;
}
